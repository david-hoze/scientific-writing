-- | CSS (Calderbank-Shor-Steane) quantum error correcting codes.
--
-- A CSS code is defined by two binary parity check matrices H_X and H_Z
-- satisfying the orthogonality constraint H_X * H_Z^T = 0.
module QEC.Code.CSS
  ( CSSCode(..)
  , CSSCodeError(..)
  , mkCSSCode
  , cssNumQubits
  , cssNumLogical
  , cssDistance
  , cssXDistance
  , cssZDistance
  ) where

import QEC.GF2
import QEC.GF2.Matrix
import QEC.GF2.Gauss

------------------------------------------------------------------------
-- Types
------------------------------------------------------------------------

-- | A CSS code defined by X-type and Z-type parity check matrices.
data CSSCode = CSSCode
  { cssHX :: !BinMatrix  -- ^ X-stabilizer parity check matrix
  , cssHZ :: !BinMatrix  -- ^ Z-stabilizer parity check matrix
  } deriving stock (Show, Eq)

-- | Errors that can occur when constructing a CSS code.
data CSSCodeError
  = DimensionMismatch Int Int  -- ^ H_X has n1 cols, H_Z has n2 cols
  | OrthogonalityViolation     -- ^ H_X * H_Z^T /= 0
  deriving stock (Show, Eq)

------------------------------------------------------------------------
-- Smart constructor
------------------------------------------------------------------------

-- | Construct a CSS code, verifying that H_X and H_Z have the same
-- number of columns and satisfy H_X * H_Z^T = 0.
mkCSSCode :: BinMatrix -> BinMatrix -> Either CSSCodeError CSSCode
mkCSSCode hx hz
  | nx /= nz = Left (DimensionMismatch nx nz)
  | bmMul hx (bmTranspose hz) /= bmZero mx mz = Left OrthogonalityViolation
  | otherwise = Right (CSSCode hx hz)
  where
    nx = bmNumCols hx
    nz = bmNumCols hz
    mx = bmNumRows hx
    mz = bmNumRows hz

------------------------------------------------------------------------
-- Code parameters
------------------------------------------------------------------------

-- | Number of physical qubits (= number of columns in H_X or H_Z).
cssNumQubits :: CSSCode -> Int
cssNumQubits = bmNumCols . cssHX

-- | Number of logical qubits: k = n - rank(H_X) - rank(H_Z).
cssNumLogical :: CSSCode -> Int
cssNumLogical code = n - rank (cssHX code) - rank (cssHZ code)
  where n = cssNumQubits code

-- | Code distance (minimum weight of a non-trivial logical operator).
-- This is @min(dX, dZ)@ where dX is the X-distance and dZ is the Z-distance.
-- Computed by brute-force search over coset representatives.
-- This is exponential in general; only use for small codes.
cssDistance :: CSSCode -> Int
cssDistance code = min (cssXDistance code) (cssZDistance code)

-- | X-distance: minimum weight of a non-trivial X-type logical operator.
-- X logicals are in ker(H_Z) \ rowspace(H_X).
cssXDistance :: CSSCode -> Int
cssXDistance code = codeDistance (cssHZ code) (cssHX code)

-- | Z-distance: minimum weight of a non-trivial Z-type logical operator.
-- Z logicals are in ker(H_X) \ rowspace(H_Z).
cssZDistance :: CSSCode -> Int
cssZDistance code = codeDistance (cssHX code) (cssHZ code)

-- | Distance for one side: minimum weight of v such that
-- H_check * v = 0 but v is not in rowspace(H_stab).
-- v is in ker(H_check) but not in rowspace(H_stab).
codeDistance :: BinMatrix -> BinMatrix -> Int
codeDistance hCheck hStab =
  case logicalReps of
    [] -> cssN  -- no logical qubits on this side
    _  -> minimum [ minWeightInCoset k stabRows | k <- logicalReps ]
  where
    cssN = bmNumCols hCheck
    -- Kernel of H_check: all v with H_check * v = 0
    kerVecs = kernel hCheck
    -- Rowspace of H_stab: generated by rows of H_stab
    stabRows = [ bmGetRow hStab i | i <- [0 .. bmNumRows hStab - 1] ]

    -- Find which kernel vectors are not in the span of stabilizer rows
    -- by checking if adding them increases rank
    stabRank = rank (if null stabRows then bmZero 0 cssN else bmFromRows stabRows)

    logicalReps = filter isLogical kerVecs
    isLogical v =
      let augmented = if null stabRows
            then bmFromRows [v]
            else bmFromRows (stabRows ++ [v])
      in rank augmented > stabRank

    -- Minimum weight in the coset v + rowspace(H_stab)
    -- For small codes, enumerate all combinations of stabilizer rows
    minWeightInCoset v stabs = minimum $
      bvWeight v : [ bvWeight (foldl bvXor v subset)
                   | subset <- subsequences stabs
                   , not (null subset) ]

    -- All non-empty subsequences
    subsequences [] = []
    subsequences (x:xs) = [x] : [ x:ys | ys <- subsequences xs ]
                          ++ subsequences xs
